import { relations, type InferEnum } from "drizzle-orm";
import {
	pgTable,
	text,
	timestamp,
	boolean,
	pgEnum,
	uniqueIndex,
	bigserial,
	index,
	jsonb,
} from "drizzle-orm/pg-core";
import { typeid } from "typeid-js";
import { project, apikey, organization } from "./auth";
import {
	AVAILABLE_CHANNELS,
	AVAILABLE_MESSAGE_STATUSES,
	AVAILABLE_PROVIDER_TYPES,
} from "@repo/shared";

/**
 * Enum defining the supported notification channels.
 */
export const channelEnum = pgEnum("channel", AVAILABLE_CHANNELS);

export type Channel = InferEnum<typeof channelEnum>;

/**
 * Enum defining the possible statuses of a message throughout its lifecycle.
 */
export const messageStatusEnum = pgEnum(
	"message_status",
	AVAILABLE_MESSAGE_STATUSES,
);

export type MessageStatus = InferEnum<typeof messageStatusEnum>;

/**
 * Enum defining the possible types of notification providers.
 */
export const providerTypeEnum = pgEnum(
	"provider_type",
	AVAILABLE_PROVIDER_TYPES,
);

export type ProviderType = InferEnum<typeof providerTypeEnum>;

/**
 * Stores user-provided credentials for accessing external notification providers.
 * Credentials are encrypted before being stored in the 'credentials' field.
 * Each credential set is linked to a specific team and identified by a unique slug within that team.
 */
export const providerCredential = pgTable(
	"provider_credential",
	{
		id: text("id")
			.primaryKey()
			.$defaultFn(() => typeid("prvc").toString()),
		organizationId: text("organization_id")
			.notNull()
			.references(() => organization.id, { onDelete: "cascade" }),
		projectId: text("project_id")
			.references(() => project.id, { onDelete: "cascade" }),
		slug: text("slug").notNull(),
		channelType: channelEnum("channel_type").notNull(),
		providerType: providerTypeEnum("provider_type"),
		name: text("name").notNull(),
		credentials: jsonb("credentials").$type<Record<string, string>>().notNull(),
		isActive: boolean("is_active").default(true).notNull(),
		createdAt: timestamp("created_at").defaultNow().notNull(),
		updatedAt: timestamp("updated_at").$onUpdate(() => new Date()),
	},
	(t) => [
		uniqueIndex("provider_credential_org_project_slug_unique_idx").on(
			t.organizationId,
			t.projectId,
			t.slug,
		),
		index("provider_credential_organization_idx").on(t.organizationId),
		index("provider_credential_project_idx").on(t.projectId),
	],
);

/**
 * Defines the relationship between provider credentials, organizations, and optionally projects.
 * Each credential belongs to one organization and optionally one project.
 */
export const providerCredentialRelations = relations(
	providerCredential,
	({ one }) => ({
		organization: one(organization, {
			fields: [providerCredential.organizationId],
			references: [organization.id],
		}),
		project: one(project, {
			fields: [providerCredential.projectId],
			references: [project.id],
		}),
	}),
);

/**
 * Represents a single notification message request and tracks its state.
 * Linked to the team that owns it, the API key used, and the provider credentials used for sending.
 */
export const message = pgTable(
	"message",
	{
		id: text("id")
			.primaryKey()
			.$defaultFn(() => typeid("mesg").toString()), // Unique identifier for the message, generated by the application
		projectId: text("project_id")
			.notNull()
			.references(() => project.id, { onDelete: "cascade" }),
		apiKeyId: text("api_key_id").references(() => apikey.id, {
			onDelete: "set null", // Keep message record even if API key is deleted
		}),
		providerCredentialId: text("provider_credential_id")
			.notNull()
			.references(() => providerCredential.id, { onDelete: "restrict" }), // Prevent deleting credentials if messages used them
		channel: channelEnum("channel").notNull(), // Target delivery channel
		recipient: text("recipient").notNull(), // Destination address/identifier
		payload: jsonb("payload").notNull(), // Original content/data sent in the API request
		status: messageStatusEnum("status").default("queued").notNull(), // Current status of the message
		statusReason: text("status_reason"), // Additional details for status (e.g., error message)
		lastStatusAt: timestamp("last_status_at").defaultNow().notNull(), // When the status field was last updated
		createdAt: timestamp("created_at").defaultNow().notNull(),
		updatedAt: timestamp("updated_at").$onUpdate(() => new Date()),
	},
	(t) => [
		// Index for efficient lookup by team and status
		index("message_project_status_idx").on(t.projectId, t.status),
		// Index for querying by API key
		index("message_api_key_idx").on(t.apiKeyId),
		// Index for querying by credential
		index("message_credential_idx").on(t.providerCredentialId),
	],
);

/**
 * Defines relationships for the message table.
 * Each message belongs to a team, an API key (optionally), and provider credentials.
 * Each message can have multiple status events.
 */
export const messageRelations = relations(message, ({ one, many }) => ({
	project: one(project, {
		fields: [message.projectId],
		references: [project.id],
	}),
	apiKey: one(apikey, {
		fields: [message.apiKeyId],
		references: [apikey.id],
	}),
	providerCredential: one(providerCredential, {
		fields: [message.providerCredentialId],
		references: [providerCredential.id],
	}),
	events: many(messageEvent), // A message can have many events
}));

/**
 * Stores a detailed audit trail of status changes for each message.
 * This provides a history of the message's journey through the system.
 */
export const messageEvent = pgTable(
	"message_event",
	{
		// Using bigserial for a simple auto-incrementing ID for events
		id: bigserial("id", { mode: "number" }).primaryKey(),
		messageId: text("message_id")
			.notNull()
			.references(() => message.id, { onDelete: "cascade" }), // Link back to the message
		status: messageStatusEnum("status").notNull(), // The status being recorded at this event time
		details: jsonb("details"), // Any relevant data associated with this event (e.g., provider response)
		occurredAt: timestamp("occurred_at").defaultNow().notNull(), // When this specific status event happened
	},
	(t) => [
		// Index for querying events for a specific message efficiently
		index("message_event_message_idx").on(t.messageId),
	],
);

/**
 * Defines the relationship for message events.
 * Each event belongs to one message.
 */
export const messageEventRelations = relations(messageEvent, ({ one }) => ({
	message: one(message, {
		fields: [messageEvent.messageId],
		references: [message.id],
	}),
}));

/**
 * Stores configuration for outbound webhooks to notify user applications about message status changes.
 * Linked to the team that owns the webhook configuration.
 */
export const webhookEndpoint = pgTable(
	"webhook_endpoint",
	{
		id: text("id")
			.primaryKey()
			.$defaultFn(() => typeid("whep").toString()), // Unique ID for the webhook configuration
		projectId: text("project_id")
			.notNull()
			.references(() => project.id, { onDelete: "cascade" }),
		url: text("url").notNull(), // Target URL for the webhook POST request
		secret: text("secret"), // Optional secret for signing/verifying requests (store securely)
		// Store event types as JSON array for flexibility
		eventTypes: jsonb("event_types").$type<string[]>().notNull(), // Message statuses that trigger this webhook
		isActive: boolean("is_active").default(true).notNull(), // Whether this webhook endpoint is enabled
		createdAt: timestamp("created_at").defaultNow().notNull(),
		updatedAt: timestamp("updated_at").$onUpdate(() => new Date()),
	},
	(t) => [
		// Index for efficient lookup by team
		index("webhook_endpoint_project_idx").on(t.projectId),
	],
);

/**
 * Defines the relationship for webhook endpoints.
 * Each endpoint belongs to one team.
 */
export const webhookEndpointRelations = relations(
	webhookEndpoint,
	({ one }) => ({
		project: one(project, {
			fields: [webhookEndpoint.projectId],
			references: [project.id],
		}),
	}),
);
